//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g 2022-03-04 23:11:48

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


   using TranslatorLab;



using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class labParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "BOOL", "BY", "CHAR", "COMMA", "CYCLE", "DEC", "DIV", "ELSE", "EQ", "EQUAL", "ESC_SEQ", "EXPONENT", "FLOAT", "GE", "GT", "HEX_DIGIT", "ID", "IF", "INC", "INT", "LBRACKET", "LE", "LPAREN", "LT", "MINUS", "MUL", "NE", "OCTAL_ESC", "OR", "PLUS", "QUANC", "RBRACKET", "RPAREN", "SEMI", "SWITCH", "TBOOL", "TCHAR", "TFLOAT", "TINT", "UNICODE_ESC", "WS", "':'"
	};
	public const int EOF=-1;
	public const int T__46=46;
	public const int AND=4;
	public const int BOOL=5;
	public const int BY=6;
	public const int CHAR=7;
	public const int COMMA=8;
	public const int CYCLE=9;
	public const int DEC=10;
	public const int DIV=11;
	public const int ELSE=12;
	public const int EQ=13;
	public const int EQUAL=14;
	public const int ESC_SEQ=15;
	public const int EXPONENT=16;
	public const int FLOAT=17;
	public const int GE=18;
	public const int GT=19;
	public const int HEX_DIGIT=20;
	public const int ID=21;
	public const int IF=22;
	public const int INC=23;
	public const int INT=24;
	public const int LBRACKET=25;
	public const int LE=26;
	public const int LPAREN=27;
	public const int LT=28;
	public const int MINUS=29;
	public const int MUL=30;
	public const int NE=31;
	public const int OCTAL_ESC=32;
	public const int OR=33;
	public const int PLUS=34;
	public const int QUANC=35;
	public const int RBRACKET=36;
	public const int RPAREN=37;
	public const int SEMI=38;
	public const int SWITCH=39;
	public const int TBOOL=40;
	public const int TCHAR=41;
	public const int TFLOAT=42;
	public const int TINT=43;
	public const int UNICODE_ESC=44;
	public const int WS=45;

	public courseworkParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public courseworkParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return labParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g"; } }


		Emitter emitter;

		public courseworkParser(ITokenStream input, Emitter emitter): this(input)
		{
			this.emitter = emitter;
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_start_rule();
	partial void LeaveRule_start_rule();
	// $ANTLR start "start_rule"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:24:1: public start_rule : ( statement )* ;
	[GrammarRule("start_rule")]
	public void start_rule()
	{
		EnterRule_start_rule();
		EnterRule("start_rule", 1);
		TraceIn("start_rule", 1);
		try { DebugEnterRule(GrammarFileName, "start_rule");
		DebugLocation(24, 22);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:24:11: ( ( statement )* )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:24:13: ( statement )*
			{
			DebugLocation(24, 13);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:24:13: ( statement )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==CHAR||(LA1_1>=CYCLE && LA1_1<=DEC)||LA1_1==FLOAT||(LA1_1>=ID && LA1_1<=INT)||LA1_1==LPAREN||LA1_1==QUANC||(LA1_1>=SWITCH && LA1_1<=TINT)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:24:13: statement
					{
					DebugLocation(24, 13);
					PushFollow(Follow._statement_in_start_rule36);
					statement();
					PopFollow();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("start_rule", 1);
			LeaveRule("start_rule", 1);
			LeaveRule_start_rule();
		}
		DebugLocation(24, 22);
		} finally { DebugExitRule(GrammarFileName, "start_rule"); }
		return;

	}
	// $ANTLR end "start_rule"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:26:1: statement : ( declaration SEMI | if | cycle | switch | assign_exp SEMI | dec_or_inc SEMI | expression ( math_op expression )* SEMI );
	[GrammarRule("statement")]
	private void statement()
	{
		EnterRule_statement();
		EnterRule("statement", 2);
		TraceIn("statement", 2);
		ParserRuleReturnScope<IToken> math_op1 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(26, 79);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:26:11: ( declaration SEMI | if | cycle | switch | assign_exp SEMI | dec_or_inc SEMI | expression ( math_op expression )* SEMI )
			int alt3=7;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case TBOOL:
			case TCHAR:
			case TFLOAT:
			case TINT:
				{
				alt3 = 1;
				}
				break;
			case IF:
				{
				alt3 = 2;
				}
				break;
			case CYCLE:
				{
				alt3 = 3;
				}
				break;
			case SWITCH:
				{
				alt3 = 4;
				}
				break;
			case ID:
				{
				switch (input.LA(2))
				{
				case DEC:
				case INC:
					{
					alt3 = 6;
					}
					break;
				case EQUAL:
					{
					alt3 = 5;
					}
					break;
				case DIV:
				case MINUS:
				case MUL:
				case PLUS:
				case SEMI:
					{
					alt3 = 7;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 5, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case DEC:
			case INC:
				{
				alt3 = 6;
				}
				break;
			case CHAR:
			case FLOAT:
			case INT:
			case LPAREN:
			case QUANC:
				{
				alt3 = 7;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:26:13: declaration SEMI
				{
				DebugLocation(26, 13);
				PushFollow(Follow._declaration_in_statement46);
				declaration();
				PopFollow();

				DebugLocation(26, 25);
				Match(input,SEMI,Follow._SEMI_in_statement48);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:27:4: if
				{
				DebugLocation(27, 4);
				PushFollow(Follow._if_in_statement53);
				@if();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:28:4: cycle
				{
				DebugLocation(28, 4);
				PushFollow(Follow._cycle_in_statement58);
				cycle();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:29:4: switch
				{
				DebugLocation(29, 4);
				PushFollow(Follow._switch_in_statement63);
				@switch();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:30:4: assign_exp SEMI
				{
				DebugLocation(30, 4);
				PushFollow(Follow._assign_exp_in_statement68);
				assign_exp();
				PopFollow();

				DebugLocation(30, 15);
				Match(input,SEMI,Follow._SEMI_in_statement70);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:31:4: dec_or_inc SEMI
				{
				DebugLocation(31, 4);
				PushFollow(Follow._dec_or_inc_in_statement75);
				dec_or_inc();
				PopFollow();

				DebugLocation(31, 15);
				Match(input,SEMI,Follow._SEMI_in_statement77);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:32:4: expression ( math_op expression )* SEMI
				{
				DebugLocation(32, 4);
				PushFollow(Follow._expression_in_statement82);
				expression();
				PopFollow();

				DebugLocation(32, 15);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:32:15: ( math_op expression )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if ((LA2_1==DIV||(LA2_1>=MINUS && LA2_1<=MUL)||LA2_1==PLUS))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:32:16: math_op expression
						{
						DebugLocation(32, 16);
						PushFollow(Follow._math_op_in_statement85);
						math_op1=math_op();
						PopFollow();

						DebugLocation(32, 24);
						PushFollow(Follow._expression_in_statement87);
						expression();
						PopFollow();

						DebugLocation(32, 35);
						emitter.AddOperation((math_op1!=null?input.ToString(math_op1.Start,math_op1.Stop):default(string)));

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(32, 76);
				Match(input,SEMI,Follow._SEMI_in_statement93);

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 2);
			LeaveRule("statement", 2);
			LeaveRule_statement();
		}
		DebugLocation(32, 79);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return;

	}
	// $ANTLR end "statement"

	partial void EnterRule_if();
	partial void LeaveRule_if();
	// $ANTLR start "if"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:1: if : IF expression_logic ( logic_op expression_logic )* statementblock ( ELSE statementblock )? ;
	[GrammarRule("if")]
	private void @if()
	{
		EnterRule_if();
		EnterRule("if", 3);
		TraceIn("if", 3);
		ParserRuleReturnScope<IToken> logic_op2 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "if");
		DebugLocation(33, 183);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:4: ( IF expression_logic ( logic_op expression_logic )* statementblock ( ELSE statementblock )? )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:6: IF expression_logic ( logic_op expression_logic )* statementblock ( ELSE statementblock )?
			{
			DebugLocation(33, 6);
			Match(input,IF,Follow._IF_in_if100);
			DebugLocation(33, 9);
			PushFollow(Follow._expression_logic_in_if102);
			expression_logic();
			PopFollow();

			DebugLocation(33, 26);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:26: ( logic_op expression_logic )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==AND||LA4_1==OR))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:27: logic_op expression_logic
					{
					DebugLocation(33, 27);
					PushFollow(Follow._logic_op_in_if105);
					logic_op2=logic_op();
					PopFollow();

					DebugLocation(33, 36);
					PushFollow(Follow._expression_logic_in_if107);
					expression_logic();
					PopFollow();

					DebugLocation(33, 53);
					emitter.AddOperation((logic_op2!=null?input.ToString(logic_op2.Start,logic_op2.Stop):default(string)));

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(33, 95);
			emitter.AddIfLabel(true);
			DebugLocation(33, 123);
			PushFollow(Follow._statementblock_in_if115);
			statementblock();
			PopFollow();

			DebugLocation(33, 138);
			emitter.AddIfLabel();
			DebugLocation(33, 162);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:162: ( ELSE statementblock )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==ELSE))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:33:163: ELSE statementblock
				{
				DebugLocation(33, 163);
				Match(input,ELSE,Follow._ELSE_in_if120);
				DebugLocation(33, 168);
				PushFollow(Follow._statementblock_in_if122);
				statementblock();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("if", 3);
			LeaveRule("if", 3);
			LeaveRule_if();
		}
		DebugLocation(33, 183);
		} finally { DebugExitRule(GrammarFileName, "if"); }
		return;

	}
	// $ANTLR end "if"

	partial void EnterRule_cycle();
	partial void LeaveRule_cycle();
	// $ANTLR start "cycle"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:1: cycle : CYCLE LPAREN ( declaration )? SEMI ( expression_logic ( logic_op expression_logic )* )? SEMI ( assign_exp | dec_or_inc )? RPAREN statementblock ;
	[GrammarRule("cycle")]
	private void cycle()
	{
		EnterRule_cycle();
		EnterRule("cycle", 4);
		TraceIn("cycle", 4);
		ParserRuleReturnScope<IToken> logic_op3 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "cycle");
		DebugLocation(35, 173);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:7: ( CYCLE LPAREN ( declaration )? SEMI ( expression_logic ( logic_op expression_logic )* )? SEMI ( assign_exp | dec_or_inc )? RPAREN statementblock )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:9: CYCLE LPAREN ( declaration )? SEMI ( expression_logic ( logic_op expression_logic )* )? SEMI ( assign_exp | dec_or_inc )? RPAREN statementblock
			{
			DebugLocation(35, 9);
			Match(input,CYCLE,Follow._CYCLE_in_cycle133);
			DebugLocation(35, 15);
			Match(input,LPAREN,Follow._LPAREN_in_cycle135);
			DebugLocation(35, 22);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:22: ( declaration )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if (((LA6_1>=TBOOL && LA6_1<=TINT)))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:23: declaration
				{
				DebugLocation(35, 23);
				PushFollow(Follow._declaration_in_cycle138);
				declaration();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(35, 37);
			Match(input,SEMI,Follow._SEMI_in_cycle142);
			DebugLocation(35, 42);
			emitter.AddCycleLabel(true);
			DebugLocation(35, 73);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:73: ( expression_logic ( logic_op expression_logic )* )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==CHAR||LA8_1==FLOAT||LA8_1==ID||LA8_1==INT||LA8_1==LPAREN||LA8_1==QUANC))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:74: expression_logic ( logic_op expression_logic )*
				{
				DebugLocation(35, 74);
				PushFollow(Follow._expression_logic_in_cycle147);
				expression_logic();
				PopFollow();

				DebugLocation(35, 91);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:91: ( logic_op expression_logic )*
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_1 = input.LA(1);

					if ((LA7_1==AND||LA7_1==OR))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch ( alt7 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:35:92: logic_op expression_logic
						{
						DebugLocation(35, 92);
						PushFollow(Follow._logic_op_in_cycle150);
						logic_op3=logic_op();
						PopFollow();

						DebugLocation(35, 101);
						PushFollow(Follow._expression_logic_in_cycle152);
						expression_logic();
						PopFollow();

						DebugLocation(35, 118);
						emitter.AddOperation((logic_op3!=null?input.ToString(logic_op3.Start,logic_op3.Stop):default(string)));

						}
						break;

					default:
						goto loop7;
					}
				}

				loop7:
					;

				} finally { DebugExitSubRule(7); }

				DebugLocation(35, 160);
				emitter.AddCycleLabel(false, true);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(35, 200);
			emitter.AddCycleLabel(false, false, true);
			DebugLocation(36, 9);
			Match(input,SEMI,Follow._SEMI_in_cycle172);
			DebugLocation(36, 15);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:36:15: ( assign_exp | dec_or_inc )?
			int alt9=3;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ID))
			{
				int LA9_2 = input.LA(2);

				if ((LA9_2==DEC||LA9_2==INC))
				{
					alt9 = 2;
				}
				else if ((LA9_2==EQUAL))
				{
					alt9 = 1;
				}
			}
			else if ((LA9_1==DEC||LA9_1==INC))
			{
				alt9 = 2;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:36:16: assign_exp
				{
				DebugLocation(36, 16);
				PushFollow(Follow._assign_exp_in_cycle176);
				assign_exp();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:36:29: dec_or_inc
				{
				DebugLocation(36, 29);
				PushFollow(Follow._dec_or_inc_in_cycle180);
				dec_or_inc();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(36, 42);
			emitter.AddCycleLabel(false, false, false, true);
			DebugLocation(36, 94);
			Match(input,RPAREN,Follow._RPAREN_in_cycle186);
			DebugLocation(36, 101);
			PushFollow(Follow._statementblock_in_cycle188);
			statementblock();
			PopFollow();

			DebugLocation(36, 116);
			emitter.AddCycleLabel(false, false, false, false, true);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("cycle", 4);
			LeaveRule("cycle", 4);
			LeaveRule_cycle();
		}
		DebugLocation(36, 173);
		} finally { DebugExitRule(GrammarFileName, "cycle"); }
		return;

	}
	// $ANTLR end "cycle"

	partial void EnterRule_switch();
	partial void LeaveRule_switch();
	// $ANTLR start "switch"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:38:1: switch : SWITCH expression LBRACKET ( BY const ':' statementblock )+ RBRACKET ;
	[GrammarRule("switch")]
	private void @switch()
	{
		EnterRule_switch();
		EnterRule("switch", 5);
		TraceIn("switch", 5);
		ParserRuleReturnScope<IToken> const4 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "switch");
		DebugLocation(38, 245);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:38:8: ( SWITCH expression LBRACKET ( BY const ':' statementblock )+ RBRACKET )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:38:10: SWITCH expression LBRACKET ( BY const ':' statementblock )+ RBRACKET
			{
			DebugLocation(38, 10);
			Match(input,SWITCH,Follow._SWITCH_in_switch198);
			DebugLocation(38, 17);
			emitter.AddSwitchLabel(true);
			DebugLocation(38, 49);
			PushFollow(Follow._expression_in_switch202);
			expression();
			PopFollow();

			DebugLocation(38, 60);
			emitter.AddAssignStatement();
			DebugLocation(38, 92);
			Match(input,LBRACKET,Follow._LBRACKET_in_switch206);
			DebugLocation(38, 101);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:38:101: ( BY const ':' statementblock )+
			int cnt10=0;
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==BY))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:38:102: BY const ':' statementblock
					{
					DebugLocation(38, 102);
					Match(input,BY,Follow._BY_in_switch209);
					DebugLocation(38, 105);
					PushFollow(Follow._const_in_switch211);
					const4=@const();
					PopFollow();

					DebugLocation(38, 111);
					emitter.AddSwitchLabel(false, true, (const4!=null?input.ToString(const4.Start,const4.Stop):default(string)));
					DebugLocation(38, 164);
					Match(input,46,Follow._46_in_switch216);
					DebugLocation(38, 168);
					PushFollow(Follow._statementblock_in_switch218);
					statementblock();
					PopFollow();

					DebugLocation(38, 183);
					emitter.AddSwitchLabel(false, false, (const4!=null?input.ToString(const4.Start,const4.Stop):default(string)));

					}
					break;

				default:
					if (cnt10 >= 1)
						goto loop10;

					EarlyExitException eee10 = new EarlyExitException( 10, input );
					DebugRecognitionException(eee10);
					throw eee10;
				}
				cnt10++;
			}
			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(38, 238);
			Match(input,RBRACKET,Follow._RBRACKET_in_switch224);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("switch", 5);
			LeaveRule("switch", 5);
			LeaveRule_switch();
		}
		DebugLocation(38, 245);
		} finally { DebugExitRule(GrammarFileName, "switch"); }
		return;

	}
	// $ANTLR end "switch"

	partial void EnterRule_assign_exp();
	partial void LeaveRule_assign_exp();
	// $ANTLR start "assign_exp"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:40:1: assign_exp : assignment ( math_op expression )* ;
	[GrammarRule("assign_exp")]
	private void assign_exp()
	{
		EnterRule_assign_exp();
		EnterRule("assign_exp", 6);
		TraceIn("assign_exp", 6);
		ParserRuleReturnScope<IToken> math_op5 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_exp");
		DebugLocation(40, 115);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:40:11: ( assignment ( math_op expression )* )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:40:13: assignment ( math_op expression )*
			{
			DebugLocation(40, 13);
			PushFollow(Follow._assignment_in_assign_exp231);
			assignment();
			PopFollow();

			DebugLocation(40, 24);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:40:24: ( math_op expression )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==DIV||(LA11_1>=MINUS && LA11_1<=MUL)||LA11_1==PLUS))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:40:25: math_op expression
					{
					DebugLocation(40, 25);
					PushFollow(Follow._math_op_in_assign_exp234);
					math_op5=math_op();
					PopFollow();

					DebugLocation(40, 33);
					PushFollow(Follow._expression_in_assign_exp236);
					expression();
					PopFollow();

					DebugLocation(40, 44);
					emitter.AddOperation((math_op5!=null?input.ToString(math_op5.Start,math_op5.Stop):default(string)));

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(40, 85);
			emitter.AddAssignStatement();

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assign_exp", 6);
			LeaveRule("assign_exp", 6);
			LeaveRule_assign_exp();
		}
		DebugLocation(40, 115);
		} finally { DebugExitRule(GrammarFileName, "assign_exp"); }
		return;

	}
	// $ANTLR end "assign_exp"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();
	// $ANTLR start "declaration"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:42:1: declaration : ( type x= ID ( COMMA y= ID )* | TINT z= ID EQUAL INT | TFLOAT u= ID EQUAL FLOAT | TCHAR i= ID EQUAL CHAR | TBOOL j= ID EQUAL BOOL );
	[GrammarRule("declaration")]
	private void declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 7);
		TraceIn("declaration", 7);
		IToken x = default(IToken);
		IToken y = default(IToken);
		IToken z = default(IToken);
		IToken u = default(IToken);
		IToken i = default(IToken);
		IToken j = default(IToken);
		IToken INT6 = default(IToken);
		IToken FLOAT7 = default(IToken);
		IToken CHAR8 = default(IToken);
		IToken BOOL9 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(42, 86);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:42:14: ( type x= ID ( COMMA y= ID )* | TINT z= ID EQUAL INT | TFLOAT u= ID EQUAL FLOAT | TCHAR i= ID EQUAL CHAR | TBOOL j= ID EQUAL BOOL )
			int alt13=5;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case TINT:
				{
				int LA13_2 = input.LA(2);

				if ((LA13_2==ID))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3==EQUAL))
					{
						alt13 = 2;
					}
					else if ((LA13_3==COMMA||LA13_3==SEMI))
					{
						alt13 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case TFLOAT:
				{
				int LA13_2 = input.LA(2);

				if ((LA13_2==ID))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3==EQUAL))
					{
						alt13 = 3;
					}
					else if ((LA13_3==COMMA||LA13_3==SEMI))
					{
						alt13 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 6, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case TCHAR:
				{
				int LA13_2 = input.LA(2);

				if ((LA13_2==ID))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3==EQUAL))
					{
						alt13 = 4;
					}
					else if ((LA13_3==COMMA||LA13_3==SEMI))
					{
						alt13 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 7, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case TBOOL:
				{
				int LA13_2 = input.LA(2);

				if ((LA13_2==ID))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3==EQUAL))
					{
						alt13 = 5;
					}
					else if ((LA13_3==COMMA||LA13_3==SEMI))
					{
						alt13 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 8, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:42:17: type x= ID ( COMMA y= ID )*
				{
				DebugLocation(42, 17);
				PushFollow(Follow._type_in_declaration252);
				type();
				PopFollow();

				DebugLocation(42, 24);
				x=(IToken)Match(input,ID,Follow._ID_in_declaration257);
				DebugLocation(42, 28);
				emitter.AddDeclarationStatement((x!=null?x.Text:default(string)));
				DebugLocation(42, 72);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:42:72: ( COMMA y= ID )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if ((LA12_1==COMMA))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:42:73: COMMA y= ID
						{
						DebugLocation(42, 73);
						Match(input,COMMA,Follow._COMMA_in_declaration262);
						DebugLocation(42, 80);
						y=(IToken)Match(input,ID,Follow._ID_in_declaration266);
						DebugLocation(42, 84);
						emitter.AddDeclarationStatement((y!=null?y.Text:default(string)));

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:43:4: TINT z= ID EQUAL INT
				{
				DebugLocation(43, 4);
				Match(input,TINT,Follow._TINT_in_declaration277);
				DebugLocation(43, 10);
				z=(IToken)Match(input,ID,Follow._ID_in_declaration281);
				DebugLocation(43, 14);
				Match(input,EQUAL,Follow._EQUAL_in_declaration283);
				DebugLocation(43, 20);
				INT6=(IToken)Match(input,INT,Follow._INT_in_declaration285);
				DebugLocation(43, 24);
				emitter.AddDeclarationStatement((z!=null?z.Text:default(string)), (INT6!=null?INT6.Text:default(string)), true);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:44:4: TFLOAT u= ID EQUAL FLOAT
				{
				DebugLocation(44, 4);
				Match(input,TFLOAT,Follow._TFLOAT_in_declaration292);
				DebugLocation(44, 12);
				u=(IToken)Match(input,ID,Follow._ID_in_declaration296);
				DebugLocation(44, 16);
				Match(input,EQUAL,Follow._EQUAL_in_declaration298);
				DebugLocation(44, 22);
				FLOAT7=(IToken)Match(input,FLOAT,Follow._FLOAT_in_declaration300);
				DebugLocation(44, 28);
				emitter.AddDeclarationStatement((u!=null?u.Text:default(string)), (FLOAT7!=null?FLOAT7.Text:default(string)), true);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:45:4: TCHAR i= ID EQUAL CHAR
				{
				DebugLocation(45, 4);
				Match(input,TCHAR,Follow._TCHAR_in_declaration307);
				DebugLocation(45, 11);
				i=(IToken)Match(input,ID,Follow._ID_in_declaration311);
				DebugLocation(45, 15);
				Match(input,EQUAL,Follow._EQUAL_in_declaration313);
				DebugLocation(45, 21);
				CHAR8=(IToken)Match(input,CHAR,Follow._CHAR_in_declaration315);
				DebugLocation(45, 26);
				emitter.AddDeclarationStatement((i!=null?i.Text:default(string)), (CHAR8!=null?CHAR8.Text:default(string)), true);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:46:4: TBOOL j= ID EQUAL BOOL
				{
				DebugLocation(46, 4);
				Match(input,TBOOL,Follow._TBOOL_in_declaration322);
				DebugLocation(46, 11);
				j=(IToken)Match(input,ID,Follow._ID_in_declaration326);
				DebugLocation(46, 15);
				Match(input,EQUAL,Follow._EQUAL_in_declaration328);
				DebugLocation(46, 21);
				BOOL9=(IToken)Match(input,BOOL,Follow._BOOL_in_declaration330);
				DebugLocation(46, 26);
				emitter.AddDeclarationStatement((j!=null?j.Text:default(string)), (BOOL9!=null?BOOL9.Text:default(string)), true);

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declaration", 7);
			LeaveRule("declaration", 7);
			LeaveRule_declaration();
		}
		DebugLocation(46, 86);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_statementblock();
	partial void LeaveRule_statementblock();
	// $ANTLR start "statementblock"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:48:1: statementblock : ( statement | LBRACKET ( statement )* RBRACKET );
	[GrammarRule("statementblock")]
	private void statementblock()
	{
		EnterRule_statementblock();
		EnterRule("statementblock", 8);
		TraceIn("statementblock", 8);
		try { DebugEnterRule(GrammarFileName, "statementblock");
		DebugLocation(48, 56);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:48:15: ( statement | LBRACKET ( statement )* RBRACKET )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==CHAR||(LA15_1>=CYCLE && LA15_1<=DEC)||LA15_1==FLOAT||(LA15_1>=ID && LA15_1<=INT)||LA15_1==LPAREN||LA15_1==QUANC||(LA15_1>=SWITCH && LA15_1<=TINT)))
			{
				alt15 = 1;
			}
			else if ((LA15_1==LBRACKET))
			{
				alt15 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:48:17: statement
				{
				DebugLocation(48, 17);
				PushFollow(Follow._statement_in_statementblock339);
				statement();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:48:29: LBRACKET ( statement )* RBRACKET
				{
				DebugLocation(48, 29);
				Match(input,LBRACKET,Follow._LBRACKET_in_statementblock343);
				DebugLocation(48, 38);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:48:38: ( statement )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if ((LA14_1==CHAR||(LA14_1>=CYCLE && LA14_1<=DEC)||LA14_1==FLOAT||(LA14_1>=ID && LA14_1<=INT)||LA14_1==LPAREN||LA14_1==QUANC||(LA14_1>=SWITCH && LA14_1<=TINT)))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:48:38: statement
						{
						DebugLocation(48, 38);
						PushFollow(Follow._statement_in_statementblock345);
						statement();
						PopFollow();


						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }

				DebugLocation(48, 49);
				Match(input,RBRACKET,Follow._RBRACKET_in_statementblock348);

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statementblock", 8);
			LeaveRule("statementblock", 8);
			LeaveRule_statementblock();
		}
		DebugLocation(48, 56);
		} finally { DebugExitRule(GrammarFileName, "statementblock"); }
		return;

	}
	// $ANTLR end "statementblock"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:50:1: expression : (l= ID math_op r= ID |l= ID math_op const |l= ( INT | FLOAT | CHAR | QUANC ) math_op r= ( INT | FLOAT | CHAR | QUANC ) | const math_op ID | LPAREN expression RPAREN | const | ID );
	[GrammarRule("expression")]
	private void expression()
	{
		EnterRule_expression();
		EnterRule("expression", 9);
		TraceIn("expression", 9);
		IToken l = default(IToken);
		IToken r = default(IToken);
		IToken ID15 = default(IToken);
		IToken ID18 = default(IToken);
		ParserRuleReturnScope<IToken> math_op10 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> const11 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> math_op12 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> math_op13 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> const14 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> math_op16 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> const17 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(50, 1);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:50:12: (l= ID math_op r= ID |l= ID math_op const |l= ( INT | FLOAT | CHAR | QUANC ) math_op r= ( INT | FLOAT | CHAR | QUANC ) | const math_op ID | LPAREN expression RPAREN | const | ID )
			int alt16=7;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==DIV||(LA16_2>=MINUS && LA16_2<=MUL)||LA16_2==PLUS))
				{
					switch (input.LA(3))
					{
					case ID:
						{
						alt16 = 1;
						}
						break;
					case CHAR:
					case FLOAT:
					case INT:
					case QUANC:
						{
						alt16 = 2;
						}
						break;
					case LPAREN:
						{
						alt16 = 7;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 16, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else if ((LA16_2==LBRACKET||(LA16_2>=RPAREN && LA16_2<=SEMI)))
				{
					alt16 = 7;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CHAR:
			case FLOAT:
			case INT:
			case QUANC:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==DIV||(LA16_2>=MINUS && LA16_2<=MUL)||LA16_2==PLUS))
				{
					switch (input.LA(3))
					{
					case CHAR:
					case FLOAT:
					case INT:
					case QUANC:
						{
						alt16 = 3;
						}
						break;
					case ID:
						{
						alt16 = 4;
						}
						break;
					case LPAREN:
						{
						alt16 = 6;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 16, 6, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else if ((LA16_2==LBRACKET||(LA16_2>=RPAREN && LA16_2<=SEMI)))
				{
					alt16 = 6;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPAREN:
				{
				alt16 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:50:14: l= ID math_op r= ID
				{
				DebugLocation(50, 15);
				l=(IToken)Match(input,ID,Follow._ID_in_expression358);
				DebugLocation(50, 19);
				emitter.AddLoadID((l!=null?l.Text:default(string)));
				DebugLocation(50, 50);
				PushFollow(Follow._math_op_in_expression363);
				math_op10=math_op();
				PopFollow();

				DebugLocation(50, 59);
				r=(IToken)Match(input,ID,Follow._ID_in_expression367);
				DebugLocation(50, 63);
				emitter.AddLoadID((r!=null?r.Text:default(string)));
				DebugLocation(50, 93);
				emitter.AddOperation((math_op10!=null?input.ToString(math_op10.Start,math_op10.Stop):default(string)));

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:51:4: l= ID math_op const
				{
				DebugLocation(51, 5);
				l=(IToken)Match(input,ID,Follow._ID_in_expression378);
				DebugLocation(51, 9);
				emitter.AddLoadID((l!=null?l.Text:default(string)));
				DebugLocation(51, 39);
				PushFollow(Follow._math_op_in_expression382);
				math_op12=math_op();
				PopFollow();

				DebugLocation(51, 47);
				PushFollow(Follow._const_in_expression384);
				const11=@const();
				PopFollow();

				DebugLocation(51, 53);
				emitter.AddLoadConst((const11!=null?input.ToString(const11.Start,const11.Stop):default(string)));
				DebugLocation(51, 90);
				emitter.AddOperation((math_op12!=null?input.ToString(math_op12.Start,math_op12.Stop):default(string)));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:52:4: l= ( INT | FLOAT | CHAR | QUANC ) math_op r= ( INT | FLOAT | CHAR | QUANC )
				{
				DebugLocation(52, 5);

				l=(IToken)input.LT(1);
				if (input.LA(1)==CHAR||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==QUANC)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(52, 35);
				emitter.AddLoadConst((l!=null?l.Text:default(string)));
				DebugLocation(52, 68);
				PushFollow(Follow._math_op_in_expression413);
				math_op13=math_op();
				PopFollow();

				DebugLocation(52, 77);

				r=(IToken)input.LT(1);
				if (input.LA(1)==CHAR||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==QUANC)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(52, 107);
				emitter.AddLoadConst((r!=null?r.Text:default(string)));
				DebugLocation(52, 140);
				emitter.AddOperation((math_op13!=null?input.ToString(math_op13.Start,math_op13.Stop):default(string)));

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:53:4: const math_op ID
				{
				DebugLocation(53, 4);
				PushFollow(Follow._const_in_expression440);
				const14=@const();
				PopFollow();

				DebugLocation(53, 10);
				emitter.AddLoadConst((const14!=null?input.ToString(const14.Start,const14.Stop):default(string)));
				DebugLocation(53, 47);
				PushFollow(Follow._math_op_in_expression444);
				math_op16=math_op();
				PopFollow();

				DebugLocation(53, 55);
				ID15=(IToken)Match(input,ID,Follow._ID_in_expression446);
				DebugLocation(53, 58);
				emitter.AddLoadID((ID15!=null?ID15.Text:default(string)));
				DebugLocation(53, 89);
				emitter.AddOperation((math_op16!=null?input.ToString(math_op16.Start,math_op16.Stop):default(string)));

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:54:4: LPAREN expression RPAREN
				{
				DebugLocation(54, 4);
				Match(input,LPAREN,Follow._LPAREN_in_expression455);
				DebugLocation(54, 11);
				PushFollow(Follow._expression_in_expression457);
				expression();
				PopFollow();

				DebugLocation(54, 22);
				Match(input,RPAREN,Follow._RPAREN_in_expression459);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:55:4: const
				{
				DebugLocation(55, 4);
				PushFollow(Follow._const_in_expression464);
				const17=@const();
				PopFollow();

				DebugLocation(55, 10);
				emitter.AddLoadConst((const17!=null?input.ToString(const17.Start,const17.Stop):default(string)));

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:56:4: ID
				{
				DebugLocation(56, 4);
				ID18=(IToken)Match(input,ID,Follow._ID_in_expression471);
				DebugLocation(56, 7);
				emitter.AddLoadID((ID18!=null?ID18.Text:default(string)));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 9);
			LeaveRule("expression", 9);
			LeaveRule_expression();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expression_logic();
	partial void LeaveRule_expression_logic();
	// $ANTLR start "expression_logic"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:59:1: expression_logic : (l= ID compare_op r= ID |l= ID compare_op const |l= ( INT | FLOAT | CHAR | QUANC ) compare_op r= ( INT | FLOAT | CHAR | QUANC ) | const compare_op r= ID | LPAREN expression_logic RPAREN | ID | const );
	[GrammarRule("expression_logic")]
	private void expression_logic()
	{
		EnterRule_expression_logic();
		EnterRule("expression_logic", 10);
		TraceIn("expression_logic", 10);
		IToken l = default(IToken);
		IToken r = default(IToken);
		IToken ID25 = default(IToken);
		ParserRuleReturnScope<IToken> compare_op19 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> const20 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> compare_op21 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> compare_op22 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> const23 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> compare_op24 = default(ParserRuleReturnScope<IToken>);
		ParserRuleReturnScope<IToken> const26 = default(ParserRuleReturnScope<IToken>);

		try { DebugEnterRule(GrammarFileName, "expression_logic");
		DebugLocation(59, 1);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:59:17: (l= ID compare_op r= ID |l= ID compare_op const |l= ( INT | FLOAT | CHAR | QUANC ) compare_op r= ( INT | FLOAT | CHAR | QUANC ) | const compare_op r= ID | LPAREN expression_logic RPAREN | ID | const )
			int alt17=7;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA17_2 = input.LA(2);

				if ((LA17_2==EQ||(LA17_2>=GE && LA17_2<=GT)||LA17_2==LE||LA17_2==LT||LA17_2==NE))
				{
					int LA17_3 = input.LA(3);

					if ((LA17_3==ID))
					{
						alt17 = 1;
					}
					else if ((LA17_3==CHAR||LA17_3==FLOAT||LA17_3==INT||LA17_3==QUANC))
					{
						alt17 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 4, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA17_2==AND||LA17_2==CHAR||(LA17_2>=CYCLE && LA17_2<=DEC)||LA17_2==FLOAT||(LA17_2>=ID && LA17_2<=LBRACKET)||LA17_2==LPAREN||LA17_2==OR||LA17_2==QUANC||(LA17_2>=RPAREN && LA17_2<=TINT)))
				{
					alt17 = 6;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CHAR:
			case FLOAT:
			case INT:
			case QUANC:
				{
				int LA17_2 = input.LA(2);

				if ((LA17_2==EQ||(LA17_2>=GE && LA17_2<=GT)||LA17_2==LE||LA17_2==LT||LA17_2==NE))
				{
					int LA17_3 = input.LA(3);

					if ((LA17_3==CHAR||LA17_3==FLOAT||LA17_3==INT||LA17_3==QUANC))
					{
						alt17 = 3;
					}
					else if ((LA17_3==ID))
					{
						alt17 = 4;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 17, 6, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA17_2==AND||LA17_2==CHAR||(LA17_2>=CYCLE && LA17_2<=DEC)||LA17_2==FLOAT||(LA17_2>=ID && LA17_2<=LBRACKET)||LA17_2==LPAREN||LA17_2==OR||LA17_2==QUANC||(LA17_2>=RPAREN && LA17_2<=TINT)))
				{
					alt17 = 7;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPAREN:
				{
				alt17 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:59:19: l= ID compare_op r= ID
				{
				DebugLocation(59, 20);
				l=(IToken)Match(input,ID,Follow._ID_in_expression_logic484);
				DebugLocation(59, 24);
				emitter.AddLoadID((l!=null?l.Text:default(string)));
				DebugLocation(59, 54);
				PushFollow(Follow._compare_op_in_expression_logic488);
				compare_op19=compare_op();
				PopFollow();

				DebugLocation(59, 66);
				r=(IToken)Match(input,ID,Follow._ID_in_expression_logic492);
				DebugLocation(59, 70);
				emitter.AddLoadID((r!=null?r.Text:default(string)));
				DebugLocation(59, 100);
				emitter.AddOperation((compare_op19!=null?input.ToString(compare_op19.Start,compare_op19.Stop):default(string)));

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:60:4: l= ID compare_op const
				{
				DebugLocation(60, 5);
				l=(IToken)Match(input,ID,Follow._ID_in_expression_logic503);
				DebugLocation(60, 9);
				emitter.AddLoadID((l!=null?l.Text:default(string)));
				DebugLocation(60, 39);
				PushFollow(Follow._compare_op_in_expression_logic507);
				compare_op21=compare_op();
				PopFollow();

				DebugLocation(60, 50);
				PushFollow(Follow._const_in_expression_logic509);
				const20=@const();
				PopFollow();

				DebugLocation(60, 56);
				emitter.AddLoadConst((const20!=null?input.ToString(const20.Start,const20.Stop):default(string)));
				DebugLocation(60, 93);
				emitter.AddOperation((compare_op21!=null?input.ToString(compare_op21.Start,compare_op21.Stop):default(string)));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:61:4: l= ( INT | FLOAT | CHAR | QUANC ) compare_op r= ( INT | FLOAT | CHAR | QUANC )
				{
				DebugLocation(61, 5);

				l=(IToken)input.LT(1);
				if (input.LA(1)==CHAR||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==QUANC)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(61, 35);
				emitter.AddLoadConst((l!=null?l.Text:default(string)));
				DebugLocation(61, 68);
				PushFollow(Follow._compare_op_in_expression_logic538);
				compare_op22=compare_op();
				PopFollow();

				DebugLocation(61, 80);

				r=(IToken)input.LT(1);
				if (input.LA(1)==CHAR||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==QUANC)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(61, 110);
				emitter.AddLoadConst((r!=null?r.Text:default(string)));
				DebugLocation(61, 143);
				emitter.AddOperation((compare_op22!=null?input.ToString(compare_op22.Start,compare_op22.Stop):default(string)));

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:62:4: const compare_op r= ID
				{
				DebugLocation(62, 4);
				PushFollow(Follow._const_in_expression_logic565);
				const23=@const();
				PopFollow();

				DebugLocation(62, 10);
				emitter.AddLoadConst((const23!=null?input.ToString(const23.Start,const23.Stop):default(string)));
				DebugLocation(62, 47);
				PushFollow(Follow._compare_op_in_expression_logic569);
				compare_op24=compare_op();
				PopFollow();

				DebugLocation(62, 59);
				r=(IToken)Match(input,ID,Follow._ID_in_expression_logic573);
				DebugLocation(62, 63);
				emitter.AddLoadID((r!=null?r.Text:default(string)));
				DebugLocation(62, 93);
				emitter.AddOperation((compare_op24!=null?input.ToString(compare_op24.Start,compare_op24.Stop):default(string)));

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:63:4: LPAREN expression_logic RPAREN
				{
				DebugLocation(63, 4);
				Match(input,LPAREN,Follow._LPAREN_in_expression_logic582);
				DebugLocation(63, 11);
				PushFollow(Follow._expression_logic_in_expression_logic584);
				expression_logic();
				PopFollow();

				DebugLocation(63, 28);
				Match(input,RPAREN,Follow._RPAREN_in_expression_logic586);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:64:4: ID
				{
				DebugLocation(64, 4);
				ID25=(IToken)Match(input,ID,Follow._ID_in_expression_logic591);
				DebugLocation(64, 7);
				emitter.AddLoadID((ID25!=null?ID25.Text:default(string)));

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:65:5: const
				{
				DebugLocation(65, 5);
				PushFollow(Follow._const_in_expression_logic599);
				const26=@const();
				PopFollow();

				DebugLocation(65, 10);
				emitter.AddLoadConst((const26!=null?input.ToString(const26.Start,const26.Stop):default(string)));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression_logic", 10);
			LeaveRule("expression_logic", 10);
			LeaveRule_expression_logic();
		}
		DebugLocation(66, 1);
		} finally { DebugExitRule(GrammarFileName, "expression_logic"); }
		return;

	}
	// $ANTLR end "expression_logic"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();
	// $ANTLR start "assignment"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:68:1: assignment : ID EQUAL expression ;
	[GrammarRule("assignment")]
	private void assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 11);
		TraceIn("assignment", 11);
		IToken ID27 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(68, 63);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:68:12: ( ID EQUAL expression )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:68:14: ID EQUAL expression
			{
			DebugLocation(68, 14);
			ID27=(IToken)Match(input,ID,Follow._ID_in_assignment610);
			DebugLocation(68, 17);
			emitter.AddLValue((ID27!=null?ID27.Text:default(string)));
			DebugLocation(68, 48);
			Match(input,EQUAL,Follow._EQUAL_in_assignment614);
			DebugLocation(68, 54);
			PushFollow(Follow._expression_in_assignment616);
			expression();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignment", 11);
			LeaveRule("assignment", 11);
			LeaveRule_assignment();
		}
		DebugLocation(68, 63);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:70:1: type : ( TINT | TFLOAT | TCHAR | TBOOL );
	[GrammarRule("type")]
	private void type()
	{
		EnterRule_type();
		EnterRule("type", 12);
		TraceIn("type", 12);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(70, 36);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:70:6: ( TINT | TFLOAT | TCHAR | TBOOL )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:
			{
			DebugLocation(70, 6);
			if ((input.LA(1)>=TBOOL && input.LA(1)<=TINT))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("type", 12);
			LeaveRule("type", 12);
			LeaveRule_type();
		}
		DebugLocation(70, 36);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return;

	}
	// $ANTLR end "type"

	partial void EnterRule_const();
	partial void LeaveRule_const();
	// $ANTLR start "const"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:72:1: const : ( INT | FLOAT | CHAR | QUANC );
	[GrammarRule("const")]
	private ParserRuleReturnScope<IToken> @const()
	{
		EnterRule_const();
		EnterRule("const", 13);
		TraceIn("const", 13);
		ParserRuleReturnScope<IToken> retval = new ParserRuleReturnScope<IToken>();
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "const");
		DebugLocation(72, 34);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:72:7: ( INT | FLOAT | CHAR | QUANC )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:
			{
			DebugLocation(72, 7);
			if (input.LA(1)==CHAR||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==QUANC)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("const", 13);
			LeaveRule("const", 13);
			LeaveRule_const();
		}
		DebugLocation(72, 34);
		} finally { DebugExitRule(GrammarFileName, "const"); }
		return retval;

	}
	// $ANTLR end "const"

	partial void EnterRule_dec_or_inc();
	partial void LeaveRule_dec_or_inc();
	// $ANTLR start "dec_or_inc"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:74:1: dec_or_inc : ( ID y= ( INC | DEC ) |x= ( INC | DEC ) ID );
	[GrammarRule("dec_or_inc")]
	private void dec_or_inc()
	{
		EnterRule_dec_or_inc();
		EnterRule("dec_or_inc", 14);
		TraceIn("dec_or_inc", 14);
		IToken y = default(IToken);
		IToken x = default(IToken);
		IToken ID28 = default(IToken);
		IToken ID29 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "dec_or_inc");
		DebugLocation(74, 59);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:74:12: ( ID y= ( INC | DEC ) |x= ( INC | DEC ) ID )
			int alt18=2;
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==ID))
			{
				alt18 = 1;
			}
			else if ((LA18_1==DEC||LA18_1==INC))
			{
				alt18 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:74:14: ID y= ( INC | DEC )
				{
				DebugLocation(74, 14);
				ID28=(IToken)Match(input,ID,Follow._ID_in_dec_or_inc664);
				DebugLocation(74, 18);

				y=(IToken)input.LT(1);
				if (input.LA(1)==DEC||input.LA(1)==INC)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(74, 29);
				emitter.AddDecOrInc((ID28!=null?ID28.Text:default(string)), (y!=null?y.Text:default(string)));

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:75:4: x= ( INC | DEC ) ID
				{
				DebugLocation(75, 5);

				x=(IToken)input.LT(1);
				if (input.LA(1)==DEC||input.LA(1)==INC)
				{
					input.Consume();
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(75, 16);
				ID29=(IToken)Match(input,ID,Follow._ID_in_dec_or_inc687);
				DebugLocation(75, 19);
				emitter.AddDecOrInc((ID29!=null?ID29.Text:default(string)), (x!=null?x.Text:default(string)));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("dec_or_inc", 14);
			LeaveRule("dec_or_inc", 14);
			LeaveRule_dec_or_inc();
		}
		DebugLocation(75, 59);
		} finally { DebugExitRule(GrammarFileName, "dec_or_inc"); }
		return;

	}
	// $ANTLR end "dec_or_inc"

	partial void EnterRule_compare_op();
	partial void LeaveRule_compare_op();
	// $ANTLR start "compare_op"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:77:1: compare_op : ( GT | GE | LT | LE | EQ | NE );
	[GrammarRule("compare_op")]
	private ParserRuleReturnScope<IToken> compare_op()
	{
		EnterRule_compare_op();
		EnterRule("compare_op", 15);
		TraceIn("compare_op", 15);
		ParserRuleReturnScope<IToken> retval = new ParserRuleReturnScope<IToken>();
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "compare_op");
		DebugLocation(77, 39);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:77:11: ( GT | GE | LT | LE | EQ | NE )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:
			{
			DebugLocation(77, 11);
			if (input.LA(1)==EQ||(input.LA(1)>=GE && input.LA(1)<=GT)||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==NE)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("compare_op", 15);
			LeaveRule("compare_op", 15);
			LeaveRule_compare_op();
		}
		DebugLocation(77, 39);
		} finally { DebugExitRule(GrammarFileName, "compare_op"); }
		return retval;

	}
	// $ANTLR end "compare_op"

	partial void EnterRule_math_op();
	partial void LeaveRule_math_op();
	// $ANTLR start "math_op"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:79:1: math_op : ( MINUS | PLUS | MUL | DIV );
	[GrammarRule("math_op")]
	private ParserRuleReturnScope<IToken> math_op()
	{
		EnterRule_math_op();
		EnterRule("math_op", 16);
		TraceIn("math_op", 16);
		ParserRuleReturnScope<IToken> retval = new ParserRuleReturnScope<IToken>();
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "math_op");
		DebugLocation(79, 27);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:79:8: ( MINUS | PLUS | MUL | DIV )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:
			{
			DebugLocation(79, 8);
			if (input.LA(1)==DIV||(input.LA(1)>=MINUS && input.LA(1)<=MUL)||input.LA(1)==PLUS)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("math_op", 16);
			LeaveRule("math_op", 16);
			LeaveRule_math_op();
		}
		DebugLocation(79, 27);
		} finally { DebugExitRule(GrammarFileName, "math_op"); }
		return retval;

	}
	// $ANTLR end "math_op"

	partial void EnterRule_logic_op();
	partial void LeaveRule_logic_op();
	// $ANTLR start "logic_op"
	// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:81:1: logic_op : ( AND | OR );
	[GrammarRule("logic_op")]
	private ParserRuleReturnScope<IToken> logic_op()
	{
		EnterRule_logic_op();
		EnterRule("logic_op", 17);
		TraceIn("logic_op", 17);
		ParserRuleReturnScope<IToken> retval = new ParserRuleReturnScope<IToken>();
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "logic_op");
		DebugLocation(81, 16);
		try
		{
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:81:9: ( AND | OR )
			DebugEnterAlt(1);
			// C:\\Users\\kathrinebovkun\\Documents\\SPO\\Translator\\Lab4.g:
			{
			DebugLocation(81, 9);
			if (input.LA(1)==AND||input.LA(1)==OR)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logic_op", 17);
			LeaveRule("logic_op", 17);
			LeaveRule_logic_op();
		}
		DebugLocation(81, 16);
		} finally { DebugExitRule(GrammarFileName, "logic_op"); }
		return retval;

	}
	// $ANTLR end "logic_op"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _statement_in_start_rule36 = new BitSet(new ulong[]{0xF8809E20682UL});
		public static readonly BitSet _declaration_in_statement46 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _SEMI_in_statement48 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_in_statement53 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cycle_in_statement58 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switch_in_statement63 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_exp_in_statement68 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _SEMI_in_statement70 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _dec_or_inc_in_statement75 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _SEMI_in_statement77 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_statement82 = new BitSet(new ulong[]{0x4460000800UL});
		public static readonly BitSet _math_op_in_statement85 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_in_statement87 = new BitSet(new ulong[]{0x4460000800UL});
		public static readonly BitSet _SEMI_in_statement93 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_if100 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_logic_in_if102 = new BitSet(new ulong[]{0xF8A0BE20690UL});
		public static readonly BitSet _logic_op_in_if105 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_logic_in_if107 = new BitSet(new ulong[]{0xF8A0BE20690UL});
		public static readonly BitSet _statementblock_in_if115 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _ELSE_in_if120 = new BitSet(new ulong[]{0xF880BE20680UL});
		public static readonly BitSet _statementblock_in_if122 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CYCLE_in_cycle133 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _LPAREN_in_cycle135 = new BitSet(new ulong[]{0xF4000000000UL});
		public static readonly BitSet _declaration_in_cycle138 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _SEMI_in_cycle142 = new BitSet(new ulong[]{0x4809220080UL});
		public static readonly BitSet _expression_logic_in_cycle147 = new BitSet(new ulong[]{0x4200000010UL});
		public static readonly BitSet _logic_op_in_cycle150 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_logic_in_cycle152 = new BitSet(new ulong[]{0x4200000010UL});
		public static readonly BitSet _SEMI_in_cycle172 = new BitSet(new ulong[]{0x2000A00400UL});
		public static readonly BitSet _assign_exp_in_cycle176 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _dec_or_inc_in_cycle180 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _RPAREN_in_cycle186 = new BitSet(new ulong[]{0xF880BE20680UL});
		public static readonly BitSet _statementblock_in_cycle188 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switch198 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_in_switch202 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _LBRACKET_in_switch206 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _BY_in_switch209 = new BitSet(new ulong[]{0x801020080UL});
		public static readonly BitSet _const_in_switch211 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _46_in_switch216 = new BitSet(new ulong[]{0xF880BE20680UL});
		public static readonly BitSet _statementblock_in_switch218 = new BitSet(new ulong[]{0x1000000040UL});
		public static readonly BitSet _RBRACKET_in_switch224 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_assign_exp231 = new BitSet(new ulong[]{0x460000802UL});
		public static readonly BitSet _math_op_in_assign_exp234 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_in_assign_exp236 = new BitSet(new ulong[]{0x460000802UL});
		public static readonly BitSet _type_in_declaration252 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_declaration257 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _COMMA_in_declaration262 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_declaration266 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _TINT_in_declaration277 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_declaration281 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_declaration283 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _INT_in_declaration285 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TFLOAT_in_declaration292 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_declaration296 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_declaration298 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _FLOAT_in_declaration300 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TCHAR_in_declaration307 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_declaration311 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_declaration313 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _CHAR_in_declaration315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TBOOL_in_declaration322 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_declaration326 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_declaration328 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _BOOL_in_declaration330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statementblock339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_statementblock343 = new BitSet(new ulong[]{0xF9809E20680UL});
		public static readonly BitSet _statement_in_statementblock345 = new BitSet(new ulong[]{0xF9809E20680UL});
		public static readonly BitSet _RBRACKET_in_statementblock348 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expression358 = new BitSet(new ulong[]{0x460000800UL});
		public static readonly BitSet _math_op_in_expression363 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_expression367 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expression378 = new BitSet(new ulong[]{0x460000800UL});
		public static readonly BitSet _math_op_in_expression382 = new BitSet(new ulong[]{0x801020080UL});
		public static readonly BitSet _const_in_expression384 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_expression395 = new BitSet(new ulong[]{0x460000800UL});
		public static readonly BitSet _math_op_in_expression413 = new BitSet(new ulong[]{0x801020080UL});
		public static readonly BitSet _set_in_expression417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _const_in_expression440 = new BitSet(new ulong[]{0x460000800UL});
		public static readonly BitSet _math_op_in_expression444 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_expression446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_expression455 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_in_expression457 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _RPAREN_in_expression459 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _const_in_expression464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expression471 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expression_logic484 = new BitSet(new ulong[]{0x940C2000UL});
		public static readonly BitSet _compare_op_in_expression_logic488 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_expression_logic492 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expression_logic503 = new BitSet(new ulong[]{0x940C2000UL});
		public static readonly BitSet _compare_op_in_expression_logic507 = new BitSet(new ulong[]{0x801020080UL});
		public static readonly BitSet _const_in_expression_logic509 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_expression_logic520 = new BitSet(new ulong[]{0x940C2000UL});
		public static readonly BitSet _compare_op_in_expression_logic538 = new BitSet(new ulong[]{0x801020080UL});
		public static readonly BitSet _set_in_expression_logic542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _const_in_expression_logic565 = new BitSet(new ulong[]{0x940C2000UL});
		public static readonly BitSet _compare_op_in_expression_logic569 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_expression_logic573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_expression_logic582 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_logic_in_expression_logic584 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _RPAREN_in_expression_logic586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expression_logic591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _const_in_expression_logic599 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assignment610 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _EQUAL_in_assignment614 = new BitSet(new ulong[]{0x809220080UL});
		public static readonly BitSet _expression_in_assignment616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_dec_or_inc664 = new BitSet(new ulong[]{0x800400UL});
		public static readonly BitSet _set_in_dec_or_inc668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_dec_or_inc681 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ID_in_dec_or_inc687 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
